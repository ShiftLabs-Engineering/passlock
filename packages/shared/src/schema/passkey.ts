import * as S from '@effect/schema/Schema'
import { optional } from './utils.js'

/* Components */

const PublicKey = S.Literal('public-key')

const PubKeyCredParams = S.Struct({
  alg: S.Number,
  type: PublicKey,
})

const AuthenticatorAttachment = S.Union(S.Literal('cross-platform'), S.Literal('platform'))

const base64url = S.String

export const Transport = S.Union(
  S.Literal('ble'),
  S.Literal('hybrid'),
  S.Literal('internal'),
  S.Literal('nfc'),
  S.Literal('usb'),
)

const Credential = S.Struct({
  id: base64url,
  type: PublicKey,
  transports: optional(S.mutable(S.Array(Transport))),
})

export const UserVerification = S.Union(
  S.Literal('discouraged'),
  S.Literal('preferred'),
  S.Literal('required'),
)

export type UserVerification = S.Schema.Type<typeof UserVerification>

const ResidentKey = S.Union(S.Literal('discouraged'), S.Literal('preferred'), S.Literal('required'))

const AuthenticatorSelection = S.Struct({
  authenticatorAttachment: optional(AuthenticatorAttachment),
  requireResidentKey: optional(S.Boolean),
  residentKey: optional(ResidentKey),
  userVerification: optional(UserVerification),
})

/* Registration */

/**
 * Required by the browser to generate a passkey.
 * Wrap this into a publicKey and pass into createRequestFromJSON
 * i.e. createRequestFromJSON({ publicKey: RegistrationOptions })
 */
export const RegistrationOptions = S.Struct({
  rp: S.Struct({
    name: S.String,
    id: optional(base64url),
  }),
  user: S.Struct({
    id: base64url,
    name: S.String,
    displayName: S.String,
  }),
  challenge: base64url,
  pubKeyCredParams: S.mutable(S.Array(PubKeyCredParams)),
  timeout: optional(S.Number),
  excludeCredentials: optional(S.mutable(S.Array(Credential))),
  authenticatorSelection: optional(AuthenticatorSelection),
  attestation: optional(
    S.Union(S.Literal('direct'), S.Literal('enterprise'), S.Literal('indirect'), S.Literal('none')),
  ),
  extensions: optional(
    S.Struct({
      appid: optional(S.String),
      appidExclude: optional(S.String),
      credProps: optional(S.Boolean),
    }),
  ),
})

export type RegistrationOptions = S.Schema.Type<typeof RegistrationOptions>

/** Public key credential (generated by the browser) */
export const RegistrationCredential = S.Struct({
  id: S.String,
  type: PublicKey,
  rawId: S.String,
  authenticatorAttachment: S.optional(S.NullishOr(AuthenticatorAttachment)),
  response: S.Struct({
    clientDataJSON: S.String,
    attestationObject: S.String,
    transports: S.mutable(S.Array(Transport)),
  }),
  clientExtensionResults: S.Struct({
    appid: S.optional(S.Boolean),
    appidExclude: S.optional(S.Boolean),
    credProps: S.optional(S.Struct({ rk: S.Boolean })),
  }),
})

export type RegistrationCredential = S.Schema.Type<typeof RegistrationCredential>

/* Authentication */

/**
 * Required by the browser to authenticate a passkey.
 */
export const AuthenticationOptions = S.Struct({
  challenge: S.String,
  timeout: optional(S.Number),
  rpId: optional(S.String),
  allowCredentials: optional(S.mutable(S.Array(Credential))),
  userVerification: optional(UserVerification),
  extensions: optional(
    S.Struct({
      appid: optional(S.String),
      credProps: optional(S.Boolean),
      hmacCreateSecret: optional(S.Boolean),
    }),
  ),
})

export type AuthenticationOptions = S.Schema.Type<typeof AuthenticationOptions>

/** Browser's response to the backend's auth challenge  */
export const AuthenticationCredential = S.Struct({
  id: S.String,
  type: PublicKey,
  rawId: S.String,
  authenticatorAttachment: S.optional(S.NullishOr(S.String)),
  response: S.Struct({
    clientDataJSON: S.String,
    authenticatorData: S.String,
    signature: S.String,
    userHandle: S.NullishOr(S.String),
  }),
  clientExtensionResults: S.Struct({
    appid: S.optional(S.Boolean),
    appidExclude: S.optional(S.Boolean),
    credProps: S.optional(
      S.Struct({
        rk: S.Boolean,
      }),
    ),
  }),
})

export type AuthenticationCredential = S.Schema.Type<typeof AuthenticationCredential>
